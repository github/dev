一，编成规约
命名风格
1，代码中的命名均不能以下划线和美元符号开始，也不能以下划线和美元符号结束
2，代码命名严禁使用英文和拼音混合的方式，更不允许直接使用中文形式
3，类名强制使用单词首字母大写
4，方法名，参数名，成员变量局部变量统一使用首字母小写其余单词首字母大写
5，常量名全部大写，单词间用下划线隔开，力求语义表达完整，不要嫌名字长
6，抽象类命名使用Abstract或者Bace开头，异常类命名以Exception结尾，测试类要以它测试的类名称开始，以Test结尾
7，类型与中括号紧挨相连来便是数组
8，POJO类中布尔类型变量都不要加is前缀，否则部分框架会引起序列化错误
9，包名统一使用小写，点分隔符之间有且仅有一个自然语义的英文单词，包名统一使用单数形式，但类名如果有复数的和含义，类名可以使用附属形式
10，避免在子父类成员变量之间，或者不同的代码块的局部变量之间采用完全相同的命名，使其可读性降低
11，杜绝完全不规范的缩写，避免望文不知意
12，为了达到代码自解释的目标，任何自定义的编程元素在命名时，都要使用完整的单词组合来表达其意
13，在常量与变量命名时，便是类型的名字放在词尾，以便提升辨识度
14，如果模块，接口，类，方法使用设计模式，在命名时需体现出具体的模式
15，接口类的方法和属性不要加任何的修饰符号，保持代码的简洁性，并加上有效的javadoc注解，尽量不要在接口中定义变量，如果一定要定义变量，肯定要与接口的方法相关，并是整个应用的基础常量
16，对于servier和DAO类基于SOA里面，暴露出来的服务一定是接口，内部实现类用Impl的后缀与接口区别
       如果是形容能力的接口名称，取对应的形容词为接口名
17，枚举类名带上Enum后缀，枚举成员名称需要全部大写，单词间用下划线隔开
18，各层命名规约
	Serviec/DAO层方法命名规约
		获取单个对象的方法用get前缀
		获取多个对象的方法用list做前缀
		获取统计值方法用count做前缀
		插入的方法用save/insert做前缀
		删除的方法用remove/delete做前缀
		修改的方法用update做前缀
	领域模型命名规约
		数据对象：XXXDO,XXX即为数据表名
		数据传输对象XXXDTO,XXX为业务领域相关的名称
		展示对象：XXXVO,XXX一般为网页名称
		POJO是DO/DTO/BO/VO的统称，禁止命名成XXXPOJO
常量定义：
1，不允许任何魔法值即未经预先定义的常量，直接出现在代码中
2，在long或者Long赋值时，数值后使用大写的L，不能时小写的l，小写容易和数字1混淆，造成误解
3，不要使用一个常量类维护所有的常量，要按照常量的功能进行归类，分开维护
4，常量的服用层次有五层：跨应用共享常量，应用内共享常量，子工程内共享常量，包内共享常量，类内共享常量
5，如果变量值仅在一个固定范围内变化用enum类型来定义
代码格式：
1，如果大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格，如果非空代买块则：左大括号前不换行，左大括号后换行，右大括号前换行，右大括号后还有else等代码则不换行，表示终止的右大括号必须换行
2，左小括号和紫伏前不出现空格，右小括号和字符之间也不出现空格，左大括号前需要空格
3，if/fro/while/seitch/do等保留字与括号之间都必须加空格
4，任何二目，三目运算符的左右两边都需要加一个空格
5，采购四个空格缩进，禁止使用tab字符
6，注释的双斜线与注释的内容之间有且仅有一个空格
7，在进行强制类型转换时，右括号与强制转换值之间需要任何空格隔开
8，单行字符数限制不超过120个，超出需要换行，换行时遵循如下原则：第二行与第一行缩进四个空格，从第三行开始不需要继续缩进
						       运算符与下文一起换行
						       方法条用的点符号与下文一起换行
						       方法条用多个参数需要换行时，在逗号后进行
						       在逗号前不要换行

9，方法参数在定义或者传入时，多个参数逗号后必须加空格
10，IDE的text file enconding设置为UTF-8，IDE中文间换行符使用Unix格式，不要使用Windows格式
11，单个方法的总行数不超过80行
12，没有必要增加若干空格来使变量赋值的等号与上一行对应位置的等号对齐
13，不用逻辑，不用语义，不用业务的代码之间插入空行分隔开以医生可读性
四OOP约规
1，避免通过一个类的对象引用访问此类的静态变量或方法，无谓增加编译器的解析成本，直接用类名访问即可。
2，所有的复写方法都要加上@Override注解
3，相同参数类型，相同的业务含义，才可以使用Java的可变参数，避免使用Object
4，外部正在调用或者二方库依赖的接口不允许修改方法的签名，避免对接口的调用方产生影响，接口过时必须加@Deprecated注解，并清晰说明采用的新接口或者新服务是什么
5，不能使用过时的方法
6，Objectz的equals方法容易抛空指针异常，应使用常量或者确定有值的对象来调用equals
7，所有整型包装类对象值得比较，全部使用equals方法比较
8，浮点数之间得等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断
9，定义数据对象DO类时，属性类型要与数据库得字段相匹配
10，为了防止精度丢失，禁止使用构造方法BigDeciaml(double)得方式把double值转换成BigDecimal对象
11，关于基本数据类型与包装数据类型得使用标准如下：所有得POJO类属性必须使用包装数据类型
					RPC方法得返回值和参数必须使用包装数据类型
					所有得局部变量使用基本数据类型
12，定义DO/DTO/VO等POJO类时，不要设定任何属性得默认值
13，序列化新增属性时，请不要修改serialCersionUID值
14，构造方法里面禁止加入任何业务逻辑，如果有初始化得逻辑，请放在init方法中
15，POJO必须写toString方法，使用IDE工具：source>generate toString时，如果继承另一个POJO类，注意在前面加super.toString 
16，禁止在POJO类中，同时存在对应属性方法XXX得isxxx()和getxxx方法
17，使用索引访问String得split方法得到数组时，需做最后一个分隔符后有无内容得检查，否则会有抛IndexOutBoundsException得风险
18，当一个类有多个狗仔方法，或者同名得方式时，这些方法按照顺序放置在一起，便于阅读
19，类内方法定义的顺序依次是：公有方法或保护方法>私有方法>getter/setter方法
20，setter方法中，参数名称与类成员变量名称一致，this.成员名=参数名，在getter/setter方法中，不要增加业务逻辑，增加排查问题得难度
21，循环体内，字符串得连接方式，使用StringBuilder得append方法进行拓展
22，final可以声明类，成员变量，方法以及本地变量，下列情况下使用final关键字
	不允许被继承得类
	不允许修改得引用得域对象
	不允许被覆写得方法
	不允许运行过程中重新复制得局部变量
	避免上下文重复使用一个变量，使用final可以强制重新定义一个变量，方便更好得进行重构
23，慎用Object中得clone方法来copy对象
24，类成员与方法访问控制从严
	如果不允许外部直接通过new来创建对象，那么构造方法必须private
	工具类不允许有public或者default构造方法
	类非static成员变量并且与子类共享，必须是protected
	类非static成员变量并且仅在本类使用，必须用private
	类static成员变量如果仅在本类中使用，必须是private
	若是static成员变量，考试是否是final
	类成员方法只供类内部调用，必须是private
	类成员方法只对继承类公开，那么限制为peotected
五集合处理
1，关于hashCode和equals得处理：
	只要覆写了equals，就必须覆写hashCode
	因为set存储得是不重复得值，依据hashCode和equals得判断，set存储对象必须覆写这两个方法
	自定义对象作为Map键，那么必须覆写hashCode和equals
2，ArrayList得subList结果不可强转成ArrayList，否则会抛出ClassCastException异常
3，使用Map方法keyset()/values()/entrySet返回集合对象时，不可以对其添加元素操作，否则会抛出UnsupportedOperationExceprion异常
4，Collection类返回对象，如：emptyList()/singletonList都是immutablelist，不可对其进行添加或者删除元素得操作
5，在subList场景中，高度注意对原集合元素得增加或删除，均会导致子列表遍历，增加，删除产生ConcurrentModeificationException异常
6，使用集合转数组得方法，必须使用toArray(T() array)，传入得类型时完全一致的，长度为0的空数组
7，使用Collection接口任何实现类的addAll()方法时，都要对输出的集合参数进行NPE判断
8，使用工具类Arraus.asList()数字转换成集合时，不能使用其修改集合的相关方法，它的add/remove/clear方法会抛出UnsupportedOperationExcaption异常
9，泛型通配符<?extends T>来接收返回的数据，此写法的泛型集合不能使用add方法，而<? super T>不能使用get方法，作为接口调用赋值时易出错
10，在无泛型限制定义集合赋值给泛型限制的集合时，在使用集合元素时，需要进行instanceof判断，避免抛出ClassCastException异常
11，不要再foreach循环中进行元素的remove/add操作，remove元素请使用Itertor方式，如果并发操作，需要对Iterator让对象进行加锁
12，再JDK7版本及以上，comparator实现类要满足三个条件，不然Arrays.sort，Collections.sort会抛出IllegalArgumentException异常
13，泛型定义集合时，使用diamond语法或者全省略
14，集合初始化时，自定集合初始值大小
15，使用entrySet遍历Map类集合KV，而不是用keySet方式进行遍历
16，Map类集合K/V不能存储null值
17，合理利用好集合的有序性和稳定性，避免集合的无序性和不稳定性带来的负面影响
18，利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历，对比，去重操作
六，并发处理
1，获取单例对象需要保证线程的安全，其中的方法也要保证线程的安全
2，创建线程或线程池时，请制定有意义的线程名称，方便出错时回溯
3，线程资源必须通过线程池提供，不允许再应用中自行显式创建线程
4，线程池不允许使用Executors取创建，而是通过ThreadPoolExecutor方式，这样处理更加明确线程池运行的规则，规避资源耗尽的风险
5，SimpleDateFormat是线程不安全的类，一般不要定义为static变量，如果定于为static，必须加锁，或者使用DateUtils工具类
6，必须回收自定义的ThreadLocal变量，尤其再线程池场景下，线程经常会被复用，如果不清理自定义的ThreadLocal变量，可能会影响后续的也业务逻辑和造成内存泄漏等问题，尽量再代理中使用try-finally块进行回收
7，高并发时，同步调用应该考量锁的性能消耗，能用无锁的数据结构，就不要用锁，能锁区块，就不要锁整个方法体，能用对象锁就不要用类锁
8，对多个资源，数据库表，对象同时加锁时，需要保持一致性枷锁顺序，否则可能会造成死锁
9，再使用阻塞等待获取锁的方式中，必须再try代码块之外，并且再加锁方法与try代码块之间没有任何可能脱出异常的方法调用，加锁成功之后，再finally中无法解锁
10，再使用尝试机制来后去锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁，锁的释放规则与锁的阻塞等待方式相同
11，并发修改统一记录时，避免更新丢失，需要加锁，要么再应用层加锁，要么再缓存加锁，要么再数据库层使用乐观锁，使用version作为更新依据
12，多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，如果再定时任务中使用ScheduledExecutorService则没有这个问题
13，资金相关的金融敏感信息，使用悲观锁策略
14，使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用CountDown方法，线程执行代码注意catch异常，确保conutDown方法被执行到，避免主线程无法执行至await方法，直至超时才返回结果
15，避免Random实例被多线程使用，虽然共享该实例线程是安全的，但会因竞争同一seed导致性能下降
16，再并发的场景下，通过双重检查锁，实现延迟初始化的问题隐患，推荐解决方案中较为简单的一种，将目标属性生命为volatile型
17，volatile解决多线程内存不可见的问题，对于一写多读，是可以解决变量同步问题，但如果多写，同样无法解决线程安全问题
18，HashMap再容量不够进行resize时由于高并发可能出现死链，导致cpu飙升，再开发过程中可以使用其他数据结构或者加锁来避免此风险
19，ThreadLocal对象使用static修饰，ThreadLocal无法解决共享对象的更新问题
七，控制语句
1，再switch块中，每个case要么通过continue/break/return等终止，要么注释程序将继续执行到哪一个case为止，再一个switch块中都必须包含一个default语句并放在最后，即使他什么代码都没有
2，当switch括号内变量类型为String并且变量为外部参数时，必须先进行null判断
3，再if/else/for/while/do语句中必须使用大括号
4，再高并发的场景中，避免使用“等于”判断作为终端或者退出的条件
5，表达异常的分支时，少用if/else方式，
6，除常用方法外，不要再条件判断中执行复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性
7，不要再其他表达句中，插入赋值语句
8，循环体的语句要考量性能，非必要操作尽量移出循环体外
9，避免使用取反逻辑运算符
10，接口入参保护，这种场景常见用作批量操作的接口
11，下列情形，需要进行参数校验
	调用频次低的方法
	执行时间开销很大的方法
	需要极高稳定性和可用性的方法
	对外提供开放接口，不管时RPC/API/HTTP接口
	敏感权限入口
12，不需要进行参数校验
	极有可能被循环调用的方法，
	底层调用频度较高的方法
	被声明成private只会被自己代码调用的方法
八注释规约
1，类，类属性，类方法注释必须使用Javadoc规范，使用/**内容*/，不得使用//XXX方式
2，所有抽象方法必须使用Javadoc注释，除了返回值，参数，异常说明之外，还必须指出该方法做什么事情，实现什么功能
3，所有类都必须添加创建者和创建日期
4，方法内部单行注释，再被注释的语句上方另起一行，使用//注释，防范内部多行注释使用/**/注释，与代码对齐
5，所有枚举类型的字段必须要有注释，说明每个数据项的用户
6，与其用“半吊子”英文注释，不如用中文注释把问题说清楚，专有名字与关键字保持英文原文即可
7，代码修改的同时，注释也要进行相应的修改，尤其是参数，返回值，异常，核心逻辑等修改
8，谨慎注释掉代码，再上方详细的说明，而不是简单的注释掉，如果无用，则是删除
9，注释要求：1，准确反映设计思想和代码逻辑 2，描述业务含义，迅速了解到代码背后的信息
10，好的命名，代码结构是自解释的，注释力求精简准确，表达到位，避免出现注释的一个极端，过多过滥的注释，代码逻辑一旦修改，修改注释是相当大的负担
11，特殊注释标记，注明标记人，标记时间，及时处理和清理。
九。其他：
1，再使用正在表达式时，利用好其预编译功能，可以有效加快正则匹配速度
2，velocity调用POJO类属性时，直接使用属性名取值即可，模板引擎会自动按照规范调用POJO的getxxx()，如果boolean基本数据类型会自动调用isxxx()方法
3，后台输送给页面的变量必须加上$!{var}--中间的感叹号
4，math.random返回时double类型，取值范围为0<=x<1，注意零异常，如果想获取整数类型的随机数，不要将x放大10的若干倍，然后取整，直接使用Random对象的nextInt方法或者nextLong方法
5，获取当前毫秒数system.currentTemeMillis(),而不是new Date.getTime()
6，日期格式化时，传入pattern中表示你年份统一使用小写的y
7，不要再视图模块加入任何复杂的逻辑
8，任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存
9，即使清理不再使用的代码段或配置信息

二异常日志
一，异常处理
1，java类库中定义的可以通过预检查方式规避RuntimeException异常不应通过catch方式来处理
2，异常不要用来做流程控制，条件控制
3，catch时分清除稳定代码和非稳定代码，稳定代码时无论如何不会出错的代码，对于非稳定代码要进行区别异常类型，做对应的异常处理
4，捕获异常时为了处理它，不要捕获了却什么都不处理，如果不想处理它，请将该异常抛给它的调用者，最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容
5，有try块放到事务代码中，catch异常后，如果需要回滚事务，一定要手动回滚
6，finally块必须对资源对象，流对象关闭，有异常也需要try/catch
7，不要再finally块中return
8，捕获异常与抛出异常，必须完全匹配，或者捕获的异常是抛出异常的父类
9，调用RPC，二方包，动态生成类的相关方法时，捕捉异常必须使用Throwable类进行拦截
10，方法返回值可以为null，不强制返回空集合，或者空对象，必须添加注释充分说明什么情况下会返回null值
11，防止NPE，时程序员的基本修养，注意NPE产生的场景
12，定义时区分unchecked/checked异常，避免直接抛出new RuntimeException()，更不允许抛出Exceprition异常
13，对于公司外的http/api开放接口必须使用“错误码”，应用内部推荐异常抛出
14，避免出现重复的代码，即DRY原则
二 日志规约
1，应用中不可以直接使用日志系统Log4j，logback中的API，而应依赖使用日志框架的API，使用门面模式的日志框架，有利于维护和各个类日志处理方式的统一
2，所有日志文件至少保存15天，网络运行状态，安全相关信息，系统检测，管理后台操作，用户敏感操作需要留存相关网络日志不小于6个月
3，应用中的拓展日志命名方式，
4，在日志输出时，字符串变量间的拼接要使用占位符的方式
5，对于trace/debug/info级别的日志输出，必须进行日志级别的开关判断
6，避免重复打印日志，浪费磁盘空间，务必在log4j,xml中设置additvity=false
7，异常信息应该包括两类信息：案发现场信息，异常堆，栈信息
8，谨慎记录日志，生产环境中禁止输入debug日志，有偶选择输出info日志，使用warn来记录刚上线的业务行为信息，一定要注意日志的输入量，避免把服务器的磁盘撑爆，并及时删除这些观察日志
9，可以推荐warn日志级别来记录用户输入参数错误的情况，
10，尽量用英文来描述日志错误信息。（在国际开发环境中，必须使用英文来记录日志）

三单元测试
1，好的单元测试必须遵守AIR原则（automatic自动化，Independent独立，repeatable可重复）
2，单元测试应该时全自动执行的，并且是非交互式的，测试用例通常是被定期执行的，执行过程必自动化才有意义，输入结果需要人工检查的测试不是一个好的单元测试，单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证
3，保持单元测试的独立性，为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序
4，单元测试是可以重复执行的，不能收到外界环境的影响
5，对于单元测试，必须保证测试粒度够小，有助于精度定位问题，单测粒度之多是类级别的，一别是方法级别的
6，核心业务，核心应用，核心模块的增量代码确保单元测试通过
7，单元测试代码必须写在sre/test/java，不允许写在业务代码目录下
8，单元测试的基本目标：语句覆盖率达到70%，核心模块语句覆盖率和分支覆盖率都要达到100%
9，单元测试代码要遵守BCDE（border边界值测试，Correct正确输入，Design与设计文档相结合，Error强制错误信息输入）保证被测试模块的交付质量
10，对于数据库相关查询，更新，删除操作，不能假设数据库的数据是存在的，
11，和数据库相关的单元测试，可以设定回滚机制，不给数据库造成脏数据
12，对于不可测的代码适当时间做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范的测试代码
13，在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有的测试用例
14，单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布之后补充单元测试用例
15，为了方便测试，业务代码应该避免：
	构造方法中做的事情过多
	存在过多的全局变量和静态方法
	存在过多的外部依赖
	存在过多的条件语句
16，

四安全规约
1，隶属于用户个人的页面后者功能必须进行权限控制校验
2，用户敏感数据禁止直接展示，必须堆展示数据进行脱敏
3，用户输入的SQL参数严格使用参数绑定或组合METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库
4，用户请求传入的任何参数必须做有效性验证
5，禁止向HTML页面输出未经安全过滤或者未正确转义的用户数据
6，表单，AJAX提交必须执行CSRF安全验证
7，在使用平台资源，必须实现正确的防重放的机制，避免被滥刷而导致资源受损
8，发帖，评论，发送即使消息等用户生成内容的场景必须实现防刷，文本内容违禁词过滤等风控策略

五MySQL数据库
一建表规约
1，表达是与否的字段，必须使用is_xxx方式命名，数据类型使unsignedtinyint
2，表名，字段名都必须使用小写字母或者数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑
3，表名不使用复数名词
4，禁用保留字
5，主键索引名为pk_字段名，唯一索引名为uk_字段名，普通索引名为idx_字段名
6，小数类型为decimal，禁止使用float和double
7，如果储存的字符串长度几乎相等，使用char定长字符串类型
8，varchar使可变字符串，不与先分配储存空间，长度不要超过5000，大于则定义字段类型为text，独立出来一张表，用主键来对应，避免影响其他字段的索引效率
9，表必备三字段id，create_time ，update_time
10，表名最好遵循“业务名称_表的作用”
11，库名与应用名称一致
12，如果字段含义或对字段表示的状态追加时，需要即使更新字段注释
13，字段允许有冗余，已提高查询性能，但必须考虑数据一致，冗余字段应遵循：不是频繁修改的字段，不是varchar超长字段，不是唯一索引的字段
14，单表行数超过500万行或者单表容量超过2gb，才推荐进行分库分表
15，合适的字符储存长度，不但节约数据库空间，节约索引储存，更可以提升检索速度
二索引规约
1，业务上具有唯一特性的字段，即使多个字段的组合，也必须建成唯一索引
2，超过三个表禁止jion,需要join的字段，数据类型必须绝对一致，多表关联查询时，保证被关联的字段需要有索引
3，在varchat字段建立索引时，必须要指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可
4，页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决
5，有order by场景，注意利用索引的有序性，并放在最后，避免出现file_sort的情况，影响查询性能
6，利用覆盖索引来进行查询擦欧总，避免回表
7，利用延迟关联或者子查询优化超多分页场景
8，SQL性能优化的目标：至少要达到range级别，要求时ref级别，最好时consts级别
9，组合索引，区分度最好的在最左边
10，防止因字段类型不同造成隐式转换，导致索引失效
三SQL语句
1，不要使用count（列名）或者count(常量)来替代count(*),count(*)是SQL92定义的标准统计行数的语法，与数据库无关，跟null或者非Null有关
2，count计算列出NULL之外的不重复的行数
3，当某一列只全是NULL时，count(col)但会结果为0.但sum（col）返回结果为null，因此使用sum（）需要注意NPF问题
4，使用ISNULL（）来判断是否为NULL值
5，代码中写分页查询时，诺count为0应直接返回，避免执行后面的分页语句
6，不得使用外键与级联，一切外键的概念都必须在应用层解决
7，禁止使用存储过程，存储过程难以调式和拓展，更没有移植性。
8，数据订正时，要先select，避免出现误删除，确认无误才能执行更新语句
9，in操作能避免则避免，实在避免不了，需要评估in后面的集合元素输了，控制在1000以内
10，如果有国际化需要，所有的字符存储与表示，均以UTF-8编码，注意字符统计函数的区别
四ORM映射
1，在表查询中，一律不要用*作为查询字段列表，需要哪些字段必须明确写明
2，POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射
3，不要用resultClass当返回参数，即使所有的类属性名与数据库字段一一对应，也需要定义，每一个表也必然有一个POJO类与之对应
4，sql.xml配置参数使用：#{}，#param#不要使用${},此种方式容易出现SQL注入
5，iBATIS自带的queryForList不建议使用
6，不允许直接拿HashMap与HashTable座椅查询结果集的输出
7，更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间
8，不要写一个大而全的数据更新接口
9，@Transactional事务不要滥用，事务会影响数据库的QPS
10，<isEuqal>中的compareValue与属性值对比的常量

六工程结构
应用分层：
1，开放层接口：可以直接封装service方法，暴漏成RPC接口，通过WEB封装成http接口，进行网关安全控制流量控制
	终端显示层：各个端的木板渲染并执行显示的层，当前主要是velocity渲染，JS渲染，JSP渲染，移动端显示
	WEB：主要对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理
	Service层，相对具体的逻辑服务层	
	Manager层：通用业务处理层：具有一下特性：
		对第三放平台封装的层，预处理返回结果及转化异常信息
		对Servcie层通用能力的下沉，如缓存方案，中间件通用处理
		与DAO层交互，对多个DAO的组合复用
		DAO：数据访问层，与底层的MySQL,Oracle,Hbase等进行数据交互
		外部接口或第三方平台：包括其他部门的RPC开放接口，基础平台，其他公司的HTTP接口
2，分层异常处理在DAO层，产生异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException，不需要打印日志，因为日志在Manager/Service层一定
需要捕获并打印到日志文件中去，如果同台服务器再打印日志，浪费性能和储存，再Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场，如果Manager层与Service
同机部署，日志方式与DAO层处理一致，如果单独部署，则才管用与Service一致的处理方式，Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常导致页面无法正常渲染，那么就应该
直接跳转到友好错误页面，加上用户容易理解的错误提示信息，开放接口层要将异常处理成错误码和错误信息方式返回
3，分层领域模型规约
	DO（Data Object）：此对象与数据库结构一一对应，通过DAO层向上传输数据源对象
	DTO（Data Transfer Object）：数据传输对象，Service或者Manager向外传输对象
	BO（Business Object）：业务对象，由Service层输出封装业务逻辑的对象
	AO（Application Object）:应用对象，再Web层与Service层之间抽象的复用对象模板，贴近展示层，复用性不高
	VO（View Object）显示层对象，通常时Web向模板解析引擎层传输的对象
	Query：数据查询对象，各层接受上层的查询对象，超过2个参数的查询封装，禁止使用Map来传输
二：二方库依赖
1，定义GAV遵从一下规则：
	GroupID格式：com.{公司/BU}.业务线[.子业务线],最多四级
	ArtifactID:产品线名-模块名，语句不重复，不遗漏，先到中央仓库查证一下
	Version
2，二方库版本号命名方式：主版本好.此版本号.修订号
	主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级
	次版本号：保证相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改
	修订号：保持完整的兼容性，修复BUG，新增次要功能特性
3，线上应用不要依赖SNAPSHOT版本
4，二方库新增或者升级，保持除功能点之外的其他jar包仲裁结果不变，如果有改变必须明确评估和验证
5，二方库可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型包括枚举类型的POJO对象
6，依赖一个二方库群，必须定义一个统一的版本变量，避免版本号不一致
7，强制再子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version
8，底层的基础技术框架，核心数据管理平台，或者近硬件端系统谨慎引入第三方实现
9，所有的pom文件依赖声明放在<dependecies>语句块中，所有版本仲裁放在<dependecyManagerment>语句块中
10，二方库不要有配置项，最低限度不要再增加配置项
11，为避免应用二方库依赖冲突，二方库发布者应该遵循以下原则：
	精简可控原则
	稳定可追溯原则
三服务器
1，高并发服务器建议调小TCP协议的time_wait超时时间
2，调大服务器支持的最大最大文件句柄数file descriptor FD
3，给JVM环境参数设置-xx:+HeapDumpOnOutOfMemeoryError参数，让JVM碰到OOM场景出书dump信息
4，线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免GC后调整堆大小带来的压力
5，服务器内部重定向使用forward，外部重定向地址使用URL拼装工具类来生成，否则会带来URL维护不一致的问题和潜在的安全风险

七设计规约
1， 储存方案和底层数据结构的设计获取评审一致性通过，并沉淀成文档
2，再需求分析阶段，如果与系统交互的User超过一类并且相关的User Case超过5个 ，使用用例图来表达更加清晰的结构化需求
3，如果某个业务对象的状态超过3个，使用状态图来表达并且明确状态变化的各个触发条件
4，如果系统中某个功能的调用链路上设计的对象超过3个，使用时序图来表达并且明确各调用环节的输入和输出
5，如果系统中的模型类超过5个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系
6，如果系统中超过2个对象之间存在协作关系，并且需要复杂的处理流程，使用活动图来表示
7，需求分析与系统设计再考虑主干功能的通四海，需要充分评估异常流程与业务边界
8，类再设计与实现时要符合单一原则
9，谨慎使用继承的方式来进行拓展，优先使用聚合/组合的方式来实现
10，系统设计时，根据依赖倒置原则，尽量依赖抽象类和接口，有利于拓展与维护
11，系统设计时，注意对拓展开放，对修改闭合
12，系统设计阶段，共性业务或公共行为抽取出来公共模块，公共配置，公共类，公共方法等，避免出现重复代码或者重复配置的情况
13，避免出现：敏捷开发=讲故事+编码+发布
14，系统设计主要目的时： 明确需求，理顺逻辑，后期维护，次要目的时用于知道编码
15，设计的本质是识别和表达系统难点，找到系统的变化点，并隔离变化点
16，系统架构设计的目的
	确定系统边界，确定系统在技术层面上做与不做
	确定系统内模块之间的关系，确定模块之间的依赖关系及模块宏观输出与输入
	确定知道后续设计与演化原则，使后续的子系统或者模块设计在规定的框架内继续演化
	确实非功能性需求，：安全性，用户性，可拓展性
17，在做无障碍产品设计时，需要考虑倒：
	所有可交互的空间元素必须能被tab间聚焦，并且焦点顺序需符合自然操作逻辑
	用户登录校验和请求拦截的验证码均需提供图形验证以外的其他方式
	自定义的控件类型需要明确交互方式
