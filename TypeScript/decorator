装饰器的写法
1.普通装饰器(无法传参)
2.装饰器工厂(可传参)

装饰器就是一个方法，可以注入到类，属性，方法参数上来扩展类，属性，方法的功能。

一.类装饰器
1.可以增加类的功能。
2.可以重载构造函数，也就是，用装饰器来修改当前的构造函数。

由于有装饰器，把下面这个配置添加到tsconfig.ts里才能编译通过
{
	"resource": "/c:/project/sample/decorator.ts",
	"owner": "typescript",
	"code": "1219",
	"severity": 8,
	"message": "Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning.",
	"source": "ts",
	"startLineNumber": 10,
	"startColumn": 7,
	"endLineNumber": 10,
	"endColumn": 17
}

然而实际上还是没编译过

decorator.ts

//这个logClass是类装饰器
function logClass(target:any){
   console.log(target);
   return class extends target{            //返回一个继承target类(也就是HttpClient类)的子类.Q:为什么不像增加类的功能一样返回一个function呢
      apiUrl:any = '我是修改后的url';       //重载属性
      getData(){
         this.apiUrl = this.apiUrl+'-----'; //重载方法
         console.log(this.apiUrl);          //Q:既然属性和方法都重载，那继承干什么呢？直接新定义一个也行啊！(好像比较麻烦，而且这样更好地体现了重载)
      }
   }
}

@logClass
class HttpClient{

    public apiUrl: string | undefined;
    constructor(){
       this.apiUrl='我是构造函数里面的apiUrl';
    }

    getData(){
       console.log(this.apiUrl);
    }
}
var http = new HttpClient;
http.getData();

运行结果:
HttpClient(){
    this.apiUrl = '我是构造函数里面的apiUrl';
}
我是修改后的url-----
________________________________________________________________

以上是类装饰器重载构造函数的一个例子，除了重载还可以增加功能,这里就不举例子了。
________________________________________________________________


