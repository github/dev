Sistema de votacion multiproceso. 
Escribir un programa en C que implemente un sistema de votacion multiproceso. 
El ejercicio se divide en distintas partes diferenciadas, de manera que se puedan ir implementado y probando secuencialmente.

a) Arranque del sistema y proceso Principal:

    El sistema se debe ejecutar con dos parametros:
    ./ voting < N_PROCS > < N_SECS >
    donde voting es el nombre del ejecutable, <N_PROCS> es el numero de procesos que participaran en la votacion y <N_SECS> es el numero maximo de segundos que estara activo el sistema.
    El proceso Principal creara tantos procesos Votante como se haya especificado, y almacenara la informacion del sistema (al menos los PID de los procesos Votante) en un fichero.
    Cuando el sistema este listo, el proceso Principal enviara la señal SIGUSR1 a todos los procesos Votante.
    Cuando Principal reciba la señal de interrupcion SIGINT, enviara a los procesos Votante la señal SIGTERM para que terminen liberando sus recursos. Cuando terminen, liberara los recursos del sistema y terminara su ejecucion mostrando el mensaje "Finishing by signal".

b) Procesos Votante:

    Al arrancar, los procesos Votante quedaran en espera de que el proceso Principal les avise de que el sistema esta listo.
    Cuando reciban la señal SIGUSR1 leeran la informacion del sistema para poder enviar señales a todos los procesos implicados, y comenzaran a iterar:
        • Los procesos competiran por convertirse en el proceso Candidato (en una suerte de condicion de carrera), de forma que el primero que lo solicite a traves de señales sera el proceso Candidato.
        • El resto de procesos Votante quedaran en espera de que arranque la votacion, para elegir si aceptan o no al candidato. Esta votacion se realizara a traves de un fichero compartido por todos los procesos.
        • Cuando la votacion este lista, el proceso Candidato enviara la señal SIGUSR2 a los procesos Votante para que registren su voto. Tras esto, esperara a que finalice la votacion (es decir, a que se hayan registrado todos los votos en el fichero) alternando la comprobacion del fichero con esperas no activas de 1 ms.
        • Cuando los procesos Votante reciban la señal de votar, generaran un voto aleatorio (sı o no) y lo registraran en el fichero. Una vez votado, entraran en una espera no activa hasta la siguiente ronda.
        • Una vez finalice la votacion, el proceso Candidato mostrara los resultados con una cadena con el formato "Candidate %d => [ Y Y N Y N ] => Accepted"/"Candidate %d => [ Y N N N Y ] => Rejected", donde el numero indica el PID del proceso candidato, las letras 'Y'/'N' el sentido del voto de cada proceso, y la candidatura se acepta en el caso de que el numero de votos positivos sea mayor que el de negativos. Tras esto, realizara una espera no activa de 250 ms y arrancara una nueva ronda enviando la señal SIGUSR1.
    Los procesos Votante terminaran, liberando todos los recursos necesarios, cuando reciban la señal SIGTERM.

c) Proteccion de zonas crıticas:

    Es necesario garantizar que el sistema es robusto, de manera que no se pierda ninguna señal.
    Para ello, se deberan bloquear las señales (puede que tambien durante la ejecucion del manejador) y realizar las esperas no activas con sigsuspend.

d) Temporizacion:

    En el caso de que transcurra el numero maximo de segundos especificados como argumento del programa, el proceso Principal procedera a terminar el sistema enviando la señal SIGTERM a los procesos Votante, y terminara su ejecucion con el mensaje "Finishing by alarm".

e) Analisis de la ejecucion:

    ¿Se produce algun problema de concurrencia en el sistema descrito? ¿Es sencillo, o siquiera factible, organizar un sistema de este tipo usando unicamente señales?

f) Sincronizacion con semaforos:

    Añadir los mecanismos necesarios, usando semaforos, para que no se produzcan problemas de concurrencia, de forma que solo haya un proceso Candidato, y que no se pierda informacion en los accesos al fichero.
