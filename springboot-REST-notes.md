## Springboot REST app 

Why Use Spring Boot?
The Spring Framework has been around almost 20 years now, and has become the most popular framework in the Java community for building applications of all types and sizes. The Spring Framework is packed full of features for any scenario, and with that comes a certain level of complexity in setting up a new application. This is the problem that Spring Boot set out to solve.

Spring Boot makes it easy to create standalone, production-grade, Spring-based applications. Spring Boot takes an opinionated view of the Spring platform and third-party libraries so that you can get started with minimal fuss. Most Spring Boot applications need very little Spring configuration.

You could create a Spring Framework application from complete scratch, but there is no reason to. Spring Boot helps to get you up and running quickly so that you can focus on the business requirements of your application.

``` 
curl https://start.spring.io/starter.zip -d dependencies=web -d type=maven-project -d bootVersion=2.7.6 -o demo.zip

unzip demo.zip -d . && rm demo.zip

```
Project Structure
The project you generated was for a Spring MVC Web project that uses Maven as the build tool. If you look at the editor, you should see the following structure:

.mvn/
mvnw.cmd
HELP.md
mvnw
pom.xml
src
├── main
│   ├── java
│   │   └── com
│   │       └── example
│   │           └── demo
│   │               └── DemoApplication.java
│   └── resources
│       ├── application.properties
│       ├── static
│       └── templates
└── test
    └── java
        └── com
            └── example
                └── demo
                    └── DemoApplicationTests.java

A typical project generated by Spring Initializr contains a Spring Boot application (DemoApplication), a test, and an empty configuration. DemoApplication.java is the main entry point for your application and you will learn more about that class later in this lab.

Because Spring Initializr has detected it is a web application, the static and templates directories have been created to hold your static resources. Also, a Maven wrapper is automatically included so that you don’t have to install Maven to run this project.

Maven POM
The default build tool for a Spring Boot application is Maven. The pom.xml file is the core of a project's configuration in Maven. It is a single configuration file that contains the majority of information required to build a project in just the way you want.

Dependencies
Open up the pom.xml in the editor and locate the dependencies section:
```
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <!-- more dependencies -->
</dependencies>
```
If you've ever built a Java application for the web, you might be wondering where the rest of the dependencies are. This is because of a key feature called Spring Boot Starters that helps us manage our dependencies.

Starters are a set of convenient dependency descriptors that you can include in your application. With the starter, you get all of the required dependencies along with the confidence of knowing that all the versions play nice together. For example, if you are building a web application you can include the spring-boot-starter-web, which brings in the following:

Spring Core
Spring MVC
Tomcat
JSON Support (Jackson)

#### Spring Boot Application Entry Point
When you learned about the structure of a Spring Boot project, you were told that the class DemoApplication.java was the main entry point for your application, and now it's time to learn why.

Open up DemoApplication.java class now by clicking the link below:

/src/main/java/com/example/demo/DemoApplication.java

This class has a public static void main, the entry point for any Java application. In this method, the static method SpringApplication.run() is called and passed in the current class:

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
The @SpringBootApplication annotation is a convenience annotation that adds all of the following:

* @SpringBootConfiguration indicates that a class as a source of bean definitions for the application context.n
* @EnableAutoConfiguration indicates to Spring to start adding beans based on class path settings, other beans, and various property settings
* @ComponentScan indicates to Spring to look for other components, configurations, and services in the same package

## Runing the Application
Now that you know how to create a Spring Boot application and what the generated project looks like, there is one more thing you should learn how to do and that's run the project.

If you were working in an IDE, there might be a fancy button for you to push that would run the application. What happens if you need to start it from a terminal or as part of some startup process? That is what the Spring Boot Maven plugin that you saw earlier is going to help with.

Run the application using Maven:

./mvnw spring-boot:run

Remember that you don't actually need Maven installed because this project is using a Maven Wrapper.

The first time you run the command you will notice a lot of dependencies being downloaded and it might take a bit. If there are no errors, you should see the application start up and it should be available on port 8080:

 .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.3.0.RELEASE)

...

2020-05-23 18:09:17.535  INFO 2328 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2020-05-23 18:09:17.545  INFO 2328 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 1.738 seconds (JVM running for 2.067)
The default port of a Spring Boot application is 8080, but this is configurable.

If you stop the application by using Ctrl-C and then run it again, you should see the application start up much faster this time. This is because the dependencies are all cached.

Run the application using Maven:

./mvnw spring-boot:run

View the Application
If you want you can click the link below to open the application in a web browser:

http://8dd79ac47eff4a5cbae9dfa55ef59daa-2887151621-8080-host12nc.environments.katacoda.com

You can also hit the application from the terminal using curl. Open up a new terminal and run this command:

curl http://8dd79ac47eff4a5cbae9dfa55ef59daa-2887151621-8080-host12nc.environments.katacoda.com

If all went well, you will be staring at an error page. This is because you haven't configured any request mappings yet. If you want to continue in this series, you can check out the next lab, "Spring Boot: Create a REST Controller," where you will build a @RestController.

## Spring Boot: Create a REST Controller

Create Books Application
In this step you will create the application that you will use for this lab. Run the following command that will tell the Spring Initializr to create a new Spring Boot application:

curl https://start.spring.io/starter.zip -d groupId=com.oreilly -d artifactId=books -d name=books -d package=com.oreilly.books -d dependencies=web -d javaVersion=17 -d type=maven-project -d bootVersion=2.7.6 -o books.zip

This will package up your application into a ZIP file and download it. Unzip the generated application and delete the ZIP:

unzip books.zip -d . && rm books.zip

## Run the Books Application
Now that your application has been created, you can run it using the following command:

./mvnw spring-boot:run

If you open up a new tab in the terminal, you can run the following curl request to hit the default route /:

curl http://e3955d260e0a46ecb2aadeb75d663cad-2887301125-8080-host10nc.environments.katacoda.com

All you're getting back at this point is an error, and that is OK. You haven't created a controller that can respond to the request, but you will in the next step.

## Creating a REST Controller
Start by creating a new class in the package com.oreilly.books called BookController.java by clicking on the filename below:

/src/main/java/com/oreilly/books/BookController.java

Copy to Editorpackage com.oreilly.books;

public class BookController {

}
It is important that this class is created in the same package or sub-package of the main application class. If it is not, Spring Boot will not locate this class automatically and will need extra configuration to find it.

## @RestController
At this point, you have a normal Java class. You need a way to tell Spring that this class is special and will respond to requests. You can do that by using the @RestController annotation:

Copy to Editorpackage com.oreilly.books;

import org.springframework.web.bind.annotation.*;

@RestController
public class BookController {

}
The @RestController is known as a stereotype annotation. It provides hints for people reading the code, and for Spring, that the class plays a specific role. In this case, our class is a web @Controller, so Spring considers it when handling incoming web requests.

## @RequestMappings
In the controller you will create methods that can be accessed by a specific path and request method. If you know all of your endpoints are going to have the same base path, you can create that path at the class level using the @RequestMapping annotation:

Copy to Editorpackage com.oreilly.books;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/books")
public class BookController {

}
This tells Spring that any mapping created in this controller will start with the path /books unless overridden.

## Books Database
Before you create methods in your controller that can respond to requests, you will need some sample data to work with. This data could come from a file, database, or a simple in-memory storage like you will use today.

The premise for your application is that you will be storing a list of some of your favorite books. To get started, you will open your BookController.java class:

/src/main/java/com/oreilly/books/BookController.java

Declare a new variable called books that will hold a List<String>. In the constructor for this class, you will create three new books:

Copy to Editorpackage com.oreilly.books;

import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/books")
public class BookController {

    private List<String> books;

    public BookController() {
        books = new ArrayList<>();
        books.add("Hacking with Spring Boot 2.3");
        books.add("97 Things Every Java Programmer Should Know");
        books.add("Spring Boot: Up and Running");
    }

    // list

    // create

    // update

    // delete

}

## GET Mapping
The first method you will create in your controller is a way to return a list of all the books. You already created and initialized the books in the constructor, so as far as the method goes you can simply return that:

public List<String> list() {
    return books;
}

## @GetMapping
There is one more step that needs to get done. Spring needs to know that this is a method you want to expose to the outside world. This method will be accessed using the GET request method, and Spring has an annotation for this called @GetMapping.

Annotation for mapping HTTP GET requests onto specific handler methods. Specifically, @GetMapping is a composed annotation that acts as a shortcut for @RequestMapping(method = RequestMethod.GET).

Below the constructor, copy and paste in the following code:

Copy to Editor@GetMapping
public List<String> list() {
    return books;
}
This will tell Spring that you are exposing this endpoint on the path /books because you declared that @RequestMapping on the class level and that it should respond to GET requests.

## Testing the Endpoint
If your application is still running in the first terminal tab, stop it with Ctrl-C. To test the endpoint, rerun the application in the first tab using the following command:

./mvnw spring-boot:run

Then open up a new terminal and curl the following URL:

curl http://e3955d260e0a46ecb2aadeb75d663cad-2887301125-8080-host10nc.environments.katacoda.com/books

You don't need to specify a request method because GET is the default.

You should see the following:

["Hacking with Spring Boot 2.3","97 Things Every Java Programmer Should Know","Spring Boot: Up and Running"]

If you're doing this on your local machine and want to test each endpoint as you're developing them, I would suggest looking into Postman or Insomnia.

## POST Mapping
Next you're going to add a way for consumers of your controller to create a new book and add it to the list of books. The JSON payload of the new book will contain a single key called title, with the value being the new title of the book:

{
    "title": "NEW_TITLE_HERE"
}
Copy the following code and paste it into the BookController:

Copy to Editor@PostMapping
public void create(@RequestBody Map<String,String> payload) {
    books.add(payload.get("title"));
}
The @PostMapping annotation tells Spring that this method will accept a POST request to /books. The @RequestBody annotation tells Spring to map what is in the request body to the variable payload. Because JSON is key/value pair, a sensible data type is Map<String, String>. Finally, in the body of the method itself you will get the book title and add it to the list of books.

If your application is still running in the first terminal tab, stop it with Ctrl-C and re-run using the following command:

./mvnw spring-boot:run

Then open up a new terminal (or use the additional terminal from a previous step) and curl the following URL:

curl -X POST http://e3955d260e0a46ecb2aadeb75d663cad-2887301125-8080-host10nc.environments.katacoda.com/books -d '{"title": "TEST"}' -H "Content-Type: application/json"

After running that command, you can curl the list command again and you should see your new book in the list:

curl http://e3955d260e0a46ecb2aadeb75d663cad-2887301125-8080-host10nc.environments.katacoda.com/books

## PUT Mapping
Now that you can create new books, you will need a way to update a book. Because you have a simple string representation of our book and nothing to key off of like an ID, you are going to pass the old title and what you want the new title to be. This way your controller method can look up the current value and replace that object in the list. The JSON payload will look like this:

{
    "oldtitle": "TEST",
    "newtitle": "NEW_TEST"
}
Copy and paste the following code into your BookController:

Copy to Editor@PutMapping
public void update(@RequestBody Map<String,String> payload){
    String oldTitle = payload.get("oldtitle");
    String newTitle = payload.get("newtitle");
    if( books.contains(oldTitle) ) {
        books.set(books.indexOf(oldTitle),newTitle);
    }
}
The @PutMapping annotation tells Spring that this method will respond to PUT requests on /books. The @RequestBody annotation works exactly the same as it did on the create method. Finally, you will search the list for the book with oldtitle and if it's found you will replace that book by its index with the new title.

If your application is still running in the first terminal tab, stop it with Ctrl-C and re-run using the following command:

./mvnw spring-boot:run

Then open up a new terminal (or use the additional terminal from a previous step) and curl the following URL:

curl -X PUT http://e3955d260e0a46ecb2aadeb75d663cad-2887301125-8080-host10nc.environments.katacoda.com/books -d '{"oldtitle": "Spring Boot: Up and Running", "newtitle": "MY NEW TITLE"}' -H "Content-Type: application/json"

After running that command, you can curl the list command again and you should see the third book in the list has been changed to MY NEW TITLE:

curl http://e3955d260e0a46ecb2aadeb75d663cad-2887301125-8080-host10nc.environments.katacoda.com/books

## DELETE Mapping
Finally, you will need to remove a book from the list.

Copy and paste the following code into your BookController:

Copy to Editor@DeleteMapping
public void delete(@RequestParam String title){
    if(books.contains(title)){
        books.remove(books.indexOf(title));
    }
}
The @DeleteMapping annotation tells Spring that this method will respond to DELETE requests on /books. In this scenario, you don't need to send a JSON request body, just a simple request parameter. When you want to delete a book, you would send a DELETE request to a URL like /books?title=TEST. The @RequestParam will assign the request parameter to the variable title.

If your application is still running in the first terminal tab, stop it with Ctrl-C and re-run using the following command:

./mvnw spring-boot:run

Then open up a new terminal (or use the additional terminal from a previous step) and curl the following URL:

curl -X DELETE http://e3955d260e0a46ecb2aadeb75d663cad-2887301125-8080-host10nc.environments.katacoda.com/books?title=Spring%20Boot%3A%20Up%20and%20Running

After running that command, you can curl the list command again and you should see the third book in the list has been deleted:

curl http://e3955d260e0a46ecb2aadeb75d663cad-2887301125-8080-host10nc.environments.katacoda.com/books

# Spring Boot: Handling JSON
## Starting Application
If you have been following all of the labs in this set, you are already familiar with the application we have built so far. If not, don't worry—this lab has some starter code ready to go. In a previous lab, we built a REST controller that used a List<String> as the data type. In this lab, you will convert that over to work with a list of objects.

If you want to examine the current BookController.java, you can open it up:

/src/main/java/com/oreilly/books/BookController.java

## Working with JSON
Before we get started, there are a few terms that we should cover.

## JSON
JSON stands for JavaScript Object Notation, and it's a lightweight readable format for sharing data. As the name implies, JSON comes from the JavaScript programming language, but it is used by many languages like Java.

JSON objects are a key-value data format enclosed in {} braces. Each key-value pair is separated by a colon, and the key is a string. A simple object representing a book in JSON might look something like this:

{
  "title": "My Book Title",
  "author": "My Book Author"
}

## Serialization
In software development we sometimes use terms that can be confusing if it's the first time you're coming across it, and this is one of those. Serialization simply means to convert an object into a string. For example, let's say you had a class that represented a book in your Spring Boot application:

public class Book {

  private String title;
  private String author;

}
Serialization in the context of this tutorial is the process of converting that Java object into a JSON string. Lucky for you, there are tools to do this for us and you will learn about them later in this lab.

## Deserialization
Deserialization is the the inverse of the serialization operation and, in the context of this lab, it is the process of converting the JSON object into a Java object. If a method was passed the following JSON:

{
  "title": "My Book Title",
  "author": "My Book Author"
}
Spring Boot can take that JSON and convert it into the correct type for you automatically:

public class Book {

  private String title;
  private String author;

}

## Starting Application
Now that you are familiar with JSON, serialization, and deserialization, let's address how they fit into a Spring Boot application. Spring Boot Starters are a collection of dependencies that all work nicely together. If you open up pom.xml, you will find the dependency spring-boot-starter-web:

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>
This starter includes a list of dependencies for working with web applications. If you're working in the context of a web application, chances are you might need to work with JSON, so Spring Boot intelligently includes the following dependency:

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-json</artifactId>
</dependency>
This includes all of the required Jackson dependencies. Jackson is a standard in the Java world for JSON serialization and deserialization. As you will see later in this lab, it is because of Jackson that you can effortlessly convert objects to JSON and vice versa.

## Book POJO
If you had a chance to go through the BookController.java, you know that the collection of books is of type List<String>. In this step, you are going to convert that simple string into a Java object that can contain fields like title and author. This is still pretty simple, but you can imagine adding more properties to it.

In the main package, create a new file called /src/main/java/com/oreilly/books/Book.java with the following code:

Copy to Editorpackage com.oreilly.books;

public class Book {
    private String title;
    private String author;

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    @Override
    public String toString() {
        return "Book{" +
                "title='" + title + '\'' +
                ", author='" + author + '\'' +
                '}';
    }
}

## Book Controller
Now that you have a class that represents a single book, you will need to make some changes to the controller. Open up the following file:

/src/main/java/com/oreilly/books/BookController.java

The first thing you will need to do is update the books type to a List<Book>:

private List<Book> books;
Now that you have updated the books variable, the constructor is no longer going to work. You were previously just adding new strings to the book list. You will need to create a new book instance with the title and author:

books = new ArrayList<>();
books.add(new Book("Hacking with Spring Boot 2.3","Greg L. Turnquist"));
books.add(new Book("97 Things Every Java Programmer Should Know", "Kevlin Henney and Trisha Gee"));
books.add(new Book("Spring Boot: Up and Running","Greg L. Turnquist "));
When you are done, your BookController.java should start to look like this:

Copy to Editorpackage com.oreilly.books;

import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping("/books")
public class BookController {

    private List<Book> books;

    public BookController() {
        books = new ArrayList<>();
        books.add(new Book("Hacking with Spring Boot 2.3","Greg L. Turnquist"));
        books.add(new Book("97 Things Every Java Programmer Should Know", "Kevlin Henney and Trisha Gee"));
        books.add(new Book("Spring Boot: Up and Running","Greg L. Turnquist "));
    }

    @GetMapping
    public List<Book> list() {
        return books;
    }

}

## Updating List Endpoint
With the Book class in place, you can update the list() method in your controller. Right now the return type for this method is List<String>. Update that so it will return a list of books:

@GetMapping
public List<Book> list() {
    return books;
}


## Run the Books Application
At this point you should have everything you need to start the application and view a list of books. Run the application using the command:

./mvnw spring-boot:run

The first time you run a Spring Boot application, it will download any required dependencies.

If you click on the following link (or curl that URL in a new terminal window):

http://a85747dc4f024e429dd2d541f475f31d-2887223301-8080-host08nc.environments.katacoda.com/books

You should get the following response:

[
  {
    title: "Hacking with Spring Boot 2.3",
    author: "Greg L. Turnquist",
  },
  {
    title: "97 Things Every Java Programmer Should Know",
    author: "Kevlin Henney and Trisha Gee",
  },
  {
    title: "Spring Boot: Up and Running",
    author: "Greg L. Turnquist ",
  },
];
You didn't do anything but change the return type, and now you have a JSON response that is an array of books. This is Jackson deserializing the list of objects into an array of JSON objects. Imagine what it would take to write some type of helper class that converted the book object to a JSON string. When you're done thinking about it, aren't you happy you don't have to worry about that? 🥳

## Creating a New Book
In the previous version of this application, the book list was made up of simple strings. To create a new book, you simply passed in some JSON with a key of title and the title of the book:

@PostMapping
public void create(@RequestBody Map<String, String> payload) {
    books.add(payload.get("title"));
}
Now that you are working with a Book object, we will need to adjust this method. In the BookController.java, add the following method:

@PostMapping
public void create(@RequestBody Book book) {
    books.add(book);
}
This method takes in a Book as an argument and it is bound to the request method. What Spring will do underneath the hood is try and match the key-value pairs in the request body, and with them, try to create a new instance of a book object.

# Spring Boot: Dependency Injection

## Review Starting Code
If you have been following all of the labs in this set, you are already familiar with the application we have built so far. If not, don't worry—this lab has some starter code ready to go. In the previous lab, we built a REST controller that used a List<Book> as the data type. In this lab, you are going to move the logic in the BookController over to a service class.

Open up BookController.java so you can see what is currently going on:

/src/main/java/com/oreilly/books/BookController.java

You will notice that there is a variable called books and you are populating the list using the controller's constructor. In each of the controller's mappings, there is business logic for manipulating that list of books. A controller is meant to be dumb: it should only know how to respond to requests, and any other logic in your application should be separated out.

In this application, you have logic for Creating, Reading, Updating, and Deleting books. This type of logic is a great candidate for a service class. By extracting this logic to a service class, we make things easier and open ourself up for modification later. What if you wanted to read and store books in a database instead of in memory? Using the approach of services, this type of change would be much easier.

## Create Book Service
The first thing you need to do is to create a new class called BookService.java:

/src/main/java/com/oreilly/books/BookService.java

And copy in the following code:

Copy to Editorpackage com.oreilly.books;

import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

// service
public class BookService {

    // crud

}
You are moving over all of the code from the controller that is used to manipulate the list of books. If you copy and paste the following code into your service and then compare it to the controller, a lot looks the same. The only difference is you aren't handling requests, so you don't need a lot of the controller annotations:

Copy to Editorprivate List<Book> books;

public BookService() {
    System.out.println("BookService() called...");
    books = new ArrayList<>();
    books.add(new Book(1,"Hacking with Spring Boot 2.3","Greg L. Turnquist"));
    books.add(new Book(2,"97 Things Every Java Programmer Should Know", "Kevlin Henney and Trisha Gee"));
    books.add(new Book(3,"Spring Boot: Up and Running","Greg L. Turnquist "));
}

public List<Book> list() {
    return books;
}

public Book get(int id) {
    return books.stream().filter(b -> b.getId() == id).findFirst().orElse(null);
}

public void create(Book book) {
    if( book != null) {
        book.setId(books.size()+1);
        books.add(book);
    }
}

public void update(Book book, int id) {
    Book currentBook = books.stream().filter(b -> b.getId() == id).findFirst().orElse(null);
    if(currentBook != null) {
        books.set(books.indexOf(currentBook),book);
    }
}

public void delete(int id){
    books.removeIf(book -> book.getId() == id);
}
There is one last step you will need to do, and that is to add the @Service annotation to your class. With this annotation, you are telling Spring that this is a special type of component that you would like the framework to manage. This will make a little more sense in the next step when you get into dependency injection, but for now just know that it is required:

Copy to Editor@Service

## Dependency Injection
In software engineering, dependency injection is a technique in which an object receives other objects that it depends on. These other objects are called dependencies.

With all your business logic for manipulating the collection of books in BooksService.java, your controller now has a dependency on that service class. If your controller needs that service class, how can you get access to it? Your first thought might be to create a new instance of it, just like you would in any other Java program:

private final BookService bookService;

public BookController() {
    this.bookService = new BookService();
}
This works, but there is a problem with this approach. Each user that visits your application is going to get a new instance of your BookService. With very few users this wouldn't be a problem, but what happens when your application gets featured on the front page of Hacker News and you get flooded with traffic?

When you marked your service class with the @Service annotation, you were telling the Spring Framework that you would like it to manage that class (often referred to as a bean) for you. This means that when your application started up, Spring created an instance of the BookService class. It would be much easier to just ask Spring for that instance as opposed to creating a new instance every time, and that is exactly what you are going to do.

If you define beans managed by Spring as arguments to the constructor, they will automatically be injected for you by the framework. In a scenario where you only have a single constructor, like you do here, there is no need to use the @Autowired annotation in the controller:

private final BookService bookService;

public BookController(BookService bookService) {
    System.out.println("BookController() called...");
    this.bookService = bookService;
}
You might come across code where the constructor is annotated with @Autowired. This used to be required, but if there is only a single constructor you don't need to do this any longer.

You don't actually need to replace the controller's constructor just yet—we will do that next. In the next step, you'll refactor your controller code to use the book service for manipulating books.

## Run and Test the Application
In both the BookService.java and BookController.java classes, you added a System.out.println() statement that printed out that the constructor for this class was called. This was added so that you can see what happens when you run your application:

public BookService() {
    System.out.println("BookService() called...");
    books = new ArrayList<>();
    books.add(new Book(1,"Hacking with Spring Boot 2.3","Greg L. Turnquist"));
    books.add(new Book(2,"97 Things Every Java Programmer Should Know", "Kevlin Henney and Trisha Gee"));
    books.add(new Book(3,"Spring Boot: Up and Running","Greg L. Turnquist "));
}
public BookController(BookService bookService) {
    System.out.println("BookController() called...");
    this.bookService = bookService;
}
Remember that Spring is managing both the BookController and BookService because they have special stereotype annotations on them. The order that these classes are created in is important, though. The BookController class needs an instance of your BookService class, and Spring is smart enough to understand this.

Run the Application
From the command line, run the application using the following command:

./mvnw spring-boot:run

If this is the first time you are running the application, it will take a little bit to download all of the dependencies first. Notice the order in which the constructors were called?

BookService() called...
BookController() called...
The only thing left to do is to test out each of the controller actions and make sure your application is able to list, create, read, update, and delete books.

Open up a new terminal and use the following curl commands:

List curl http://e42a7a00c9944288af7ff4f99e70ab98-2887225349-8080-host08nc.environments.katacoda.com/books

Create curl -X POST http://e42a7a00c9944288af7ff4f99e70ab98-2887225349-8080-host08nc.environments.katacoda.com/books -H 'content-type: application/json' -d '{"title": "TEST","author": "TEST"}'

Read curl http://e42a7a00c9944288af7ff4f99e70ab98-2887225349-8080-host08nc.environments.katacoda.com/books/1

Update curl -X PUT http://e42a7a00c9944288af7ff4f99e70ab98-2887225349-8080-host08nc.environments.katacoda.com/books/4 -H 'content-type: application/json' -d '{"id": 4,"title": "NEW TEST","author": "NEW TEST"}'

Delete curl -X DELETE http://e42a7a00c9944288af7ff4f99e70ab98-2887225349-8080-host08nc.environments.katacoda.com/books/1


# Spring Boot: Handling Errors
## Review Starting Code
If you have been following all of the labs in this set, you are already familiar with the application we have built so far. If not, don't worry—this lab has some starter code ready to go. In the previous lab, we moved our business logic into a service class. In this lab you are going to learn how to return proper status codes to provide the consumer of your controller with better feedback.

Open up BookController.java:

/src/main/java/com/oreilly/books/BookController.java

Let's examine a few problems with your current REST controller that you can improve on.

Returning Correct Status Codes
When you create a new book, you will respond with a 200 (OK) status. This works, but it doesn't give the consumer any indication if the new book was created:

@PostMapping
public void create(@RequestBody Book book) {
    bookService.create(book);
}
The update() and delete() methods don't return anything. In these cases the consumer might not know the operation was success—maybe they are expecting the object to be returned:

@PutMapping("/{id}")
public void update(@RequestBody Book book, @PathVariable int id) {
    bookService.update(book,id);
}

@DeleteMapping("/{id}")
public void delete(@PathVariable int id){
    bookService.delete(id);
}
Not Found
What happens if you pass an invalid ID to the GET method?

@GetMapping("/{id}")
public Book get(@PathVariable int id) {
    return bookService.get(id);
}
Already Exists
What happens if you send the same POST request over and over? Will your controller just keep creating the same book? This seems like something you should check for:

@PostMapping
public void create(@RequestBody Book book) {
    bookService.create(book);
}
These are some examples of scenarios that might come up, and with a little bit of effort you can provide better feedback to your users.

## Returning Status Codes (CREATED)
The first problem you are going to look at is the response status code of the create() method. Run the application using the following command:

./mvnw spring-boot:run

Open up a new terminal and create a new book by sending this curl command:

Create curl -v http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books -H 'content-type: application/json' -d '{"title": "TEST","author": "TEST"}'

The -v flag (verbose) will tell curl to print out the request and response details. If you look at the status code of the response, it's currently 200 and this is what you are going to change.

Stop the application by entering Ctrl-C in the terminal window where Spring Boot is running.

@ResponseStatus
Spring makes it really easy to customize the response status code. The @ResponseStatus annotation is used to mark a method or exception class with the status code() and reason() that should be returned.

The first value is the status code you would like to return. This will be of type HttpStatus, which is an enum that contains values for all status codes. If you want to return a 201 Created, you can use HttpStatus.CREATED. In the BookController, replace the existing create() method with the following:

@ResponseStatus(HttpStatus.CREATED)
@PostMapping
public void create(@RequestBody Book book) {
    bookService.create(book);
}
That is all you need to do; now run the application and create a new book by running the curl command in a new terminal window:

./mvnw spring-boot:run

Create curl -v http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books -H 'content-type: application/json' -d '{"title": "TEST","author": "TEST"}'

If you examine the response, you should now see a status code of 201:

* upload completely sent off: 34 out of 34 bytes
< HTTP/1.1 201
< Content-Length: 0
< Date: Sat, 06 Jun 2020 19:28:02 GMT

## Returning Status Codes (NO_CONTENT)
You are going to do something similar for the update() and delete() methods. These methods do not return anything, and by convention you should let the consumer know that by returning a status code of 204 No Content.

Add the proper annotation to both the update() and delete() methods in the BookController:

@ResponseStatus(HttpStatus.NO_CONTENT)
@PutMapping("/{id}")
public void update(@RequestBody Book book, @PathVariable int id) {
    bookService.update(book,id);
}

@ResponseStatus(HttpStatus.NO_CONTENT)
@DeleteMapping("/{id}")
public void delete(@PathVariable int id){
    bookService.delete(id);
}
If the application is still running, stop it with Ctrl-C and then re-run the application:

./mvnw spring-boot:run

Open a new terminal window and run the following commands:

Update curl -v -X PUT http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books/1 -H 'content-type: application/json' -d '{"id": 4,"title": "NEW TEST","author": "NEW TEST"}'

Delete curl -v -X DELETE http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books/1

You should now see a response status code of 204:

< HTTP/1.1 204

## Book Not Found Exception
If you send a GET request for a resource that doesn't exist, like book #99, you get currently get a response status 200:

curl -v http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books/99

If someone is requesting a resource that doesn't exist, it would be helpful to let them know that the resource doesn't exist. You can do this by creating a custom exception.

Create a new file:

/src/main/java/com/oreilly/books/BookNotFoundException.java

And copy in the following code:

Copy to Editorpackage com.oreilly.books;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class BookNotFoundException extends RuntimeException {

    public BookNotFoundException(int id) {
        super("Book not found with id: " + id);
    }

}
This is just a normal exception class that extends RuntimeException. What makes this useful is the @ResponseStatus annotation that you learned about in the previous steps. This exception will return a 404 Not Found status when it is thrown.

Open up the BookController and update the GET method with the following code. When you call the book service, it will return null if it couldn't find the book by the ID. If that is the case, you can just throw a new BookNotFoundException and when it is thrown the @ResponseStatus will send the proper status code:

@GetMapping("/{id}")
public Book get(@PathVariable int id) throws BookNotFoundException {
    Book book = bookService.get(id);
    if( book == null ) {
        throw new BookNotFoundException(id);
    }
    return book;
}
If the application is still running, stop it with Ctrl-C and then run the application again:

./mvnw spring-boot:run

And run the following curl command in a new terminal window:

curl http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books/99

You now have some helpful feedback here telling you that the book you are looking for was not found:

{
    "timestamp": "2020-06-06T17:55:41.052+00:00",
    "status": 404,
    "error": "Not Found",
    "message": "",
    "path": "/books/99"
}

## Book Already Exists Exception
In the application as it currently works, you can send the same POST request over and over again and the same book will continue to be added to the list. If the application is not running, start it using the following command:

./mvnw spring-boot:run

Copy the following curl command, open a new terminal window, and run it multiple times, which will result in the same book being created over and over again:

Create curl -v http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books -H 'content-type: application/json' -d '{"title": "TEST","author": "TEST"}'

To verify, you can list out all of the books:

List curl http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books

Already Exists Exception
You are going to take a similar approach you did with a book not found exception. Create a new file:

/src/main/java/com/oreilly/books/BookAlreadyExistsException.java

And paste in the following content:

Copy to Editorpackage com.oreilly.books;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = "Book Already Exists")
public class BookAlreadyExistsException extends RuntimeException {

    public BookAlreadyExistsException(Book book) {
        super("Book already exists: " + book.toString());
    }
}
Take note of the @ResponseStatus() annotation. When you get information in the request that you determine is bad for whatever reason, a proper status code to send back is 400 Bad Request. If you look in the BookService.java class, you can see the logic for determining if a book already exists or not. This method will return true if the title of the book already exists in the list:

public boolean exists(Book book) {
    Book found = books.stream().filter(b -> b.getTitle().toLowerCase().equals(book.getTitle().toLowerCase())).findFirst().orElse(null);
    return found != null;
}
In BookController, locate the create() method. Before creating a new book, you will want to call the exists() method and, if it does exist, throw your new BookAlreadyExistsException. You can do this by updating the code as follows:

@ResponseStatus(HttpStatus.CREATED)
@PostMapping
public void create(@RequestBody Book book) throws BookAlreadyExistsException {
    if(bookService.exists(book)) {
        throw new BookAlreadyExistsException(book);
    } else {
        bookService.create(book);
    }
}
Stop the application from the terminal window where Spring Boot is running by using Ctrl-C.

Run the application again:

./mvnw spring-boot:run

Open a new terminal window and send the following request twice, which will re-create the same book. The first one should go through, but the second one should respond with a 400 Bad Request:

Create curl -v http://4c6881012a6343c5a78ac7d0d3e6b437-2887308293-8080-host10nc.environments.katacoda.com/books -H 'content-type: application/json' -d '{"title": "TEST","author": "TEST"}'

{
    "timestamp": "2020-06-06T20:13:31.099+00:00",
    "status": 400,
    "error": "Bad Request",
    "message": "",
    "path": "/books"
}








